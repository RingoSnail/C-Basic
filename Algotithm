【算法分析】

内循环：执行次数最多的简单计算，比如循环的加减、判断等

成本模型：类似于内循环，即一次完整的操作

时间复杂度：以（内循环经过排列组合次数的精确多项式）的等效无穷大为准

空间复杂度：以储存的变量数量（如数组的哈希表）的等效无穷大为准
ThreeSum brute：N ^ 3 BinarySearch：N ^ 2logN TwoPointer：N ^ 2

倍率实验 T(N)~aN^blogN 则多次运行程序时，  T(2N)~2 ^ bT(N）

【排序算法】

成本模型：比较、交换的次数

快速排序、归并排序最常用

选择排序selection：每轮从数组中选择最小元素与第一个元素交换，循环剩下的数组。~N ^ 2 / 2次比较 ~N次交换

冒泡排序bubble：从左到右交换逆序元素，每轮将最大元素移至最右侧，循环剩下的数组。若一轮没有发生交换，则说明已经有序，退出。
（或从右到左每轮将最小元素移至最左）

插入排序insertion：每轮将当前元素插入到左侧已经排序的数组中，使得插入后依然有序。每次只交换相邻逆序，总交换次数等于总逆序数。
平均需要~N ^ 2 / 4比较，~N ^ 2 / 4交换
最坏需要~N ^ 2 / 2比较，~N ^ 2 / 2交换  比较次数 = 逆序数 = 交换次数
最好需要N - 1比较，0交换

希尔排序shell：按间隔h对数组分组，每组内进行插入排序，不断缩小到h = 1。使得逆序交换距离以h为单位进行。
h的序列称为希尔序列
小于~N ^ 2，小于~aN乘以希尔序列长度

归并排序merge：归并函数：将已分两半排序的数组重新调顺位置
自顶向下归并up2down : 将数组分为两半 ~NlogN
自底向上归并down2up : 将数组分为微型数组，依次归并，逐渐归并成大数组

快速排序quicksort：通过切分元素partition将数组分为两部分进行归并排序，左部分小于等于切分，右部分相反
切分：根据切分元素的大小分别从两端扫描，将两个不符合切分的元素交换位置。
不断重复，直至两个指针相遇，将切分元素挪至相遇点。
性能分析：原地排序，递归调用需要辅助栈
最好每次都将数组分半
最坏每次切1切2

改进：小数组中切换到插入排序、三数取中作为切分元素、三向切分（小于、等于、大于重复元素）threewayquicksort
基于切分的快速选择算法partitionselection：数组经过切分后，即可找到大小排序第k的元素，依次切分，寻找出所有元素

堆排序heapsort：
堆：是完全二叉树，可以用数组表示
节点关系：k→2k / 2k + 1
上浮和下沉swimandsink：将大的子节点交换至父节点，或相反
插入元素：将新元素放至数组末尾，然后上浮至合适的位置
删除最大元素：从数组顶端删除最大元素，然后将数组最后一个元素放至顶端，再下沉至合适位置
堆排序：将最大元素置于数组末尾，经过操作可以得到一个递增序列。
构建堆：从左到右进行上浮，或从右到左进行下沉
→交换堆顶与最后一个元素，再进行下沉
复杂度：NlogN 堆有logN层，其次要对N个元素进行下沉。原地排序，不用额外空间。无法使用局部性原理进行缓存。

(补)【并查集】 union - find disjoint sets

一种树形的数据结构，用于处理一些不相交集合的合并与查询问题

quickfind：通过相同的id来寻找节点，union操作高，需保证连通的id一致

quickunion：通过树形结构指向连通节点，find操作高，需向上查找

【符号表】

储存键值对的数据结构

分为无序和有序

链表实现，二分查找实现

（补）二叉查找树 BST ：每个节点的值都大于等于其左子树中的所有节点的值而小于等于其右子树所有节点的值
其中序遍历结果递增排序

2-3查找树：2节点和3节点
让树平衡
其中序遍历结果递增排序
插入操作：插到2节点直接变3节点；插到3节点分裂成2个2节点，且将中间的键移到上方变成3节点，如果产生4节点则一直上移

红黑树：通过红色链接标识3节点：红色节点及其上一节点组成3节点
性质：红链接都为左链接
      完美黑色平衡，任意空链接到根节点的路径上的黑链接数量相同

	  ？？？左旋转、右旋转

散列表：有一个散列值类似于数组的索引，即hash

各种表的比较：插入复杂度，查找复杂度，是否有序