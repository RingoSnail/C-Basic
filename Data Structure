数据结构与算法基础

数据项之间的逻辑关系：集合，线性结构，树形结构，图形结构

【1.表】

线性表（数组）：element+index；
插入时其后元素后移，删除时其后元素前移

逻辑上相邻的元素物理地址也是相邻的，易于得到物理地址，便于访问元素

数组接口：
size(), empty(), ordered(), get(pos), 先判断范围, set(pos, e), find(e), 
binary_search(e), 先判断是否从大到小排序，low,mid,high，处理好mid+-1的边界，循环
remove(pos),所有其后元素前移，size-1，insert(pos,e)，size-1，所有其后元素后移
sort()检查是否ordered，再用冒泡法，shuffle()，依次随机交换每个位置的元素

链表：element+next + head+tail
插入删除时重新整理连线

物理存储非连续，但依靠节点指针连接起逻辑顺序

遍历不太方便，前驱一般得从head开始遍历

多项式相加：使用单向链表实现 （系数conf+指数expo）+指向；
创建三个单向链表储存两个多项式和他们的和，对应系数相加，处理系数为0、抄写并插入没有对应指数项的情况

双链表：element+next+prior；
插入删除时重新整理双向的连线，便于找前驱，而单向表需要遍历得出前驱

循环链表：tail指向了head

约瑟夫问题： 建立一个循环链，30个在船上的人标记为1，每数9个抛下一个人，标记为0，循环到还剩15个人时全部标记为教徒即可

链表接口：
size(), empty(), get_node(pos), find_node(e), build_list(array)数组转链表,
 insert(pos, e), remove(pos), reverse(), sort()选择排序

链表与数组对比：

都有前驱-后继关系，线性结构，接口类似，都可以作为栈和队列的基础结构

数组：
内存少，访问速度高，可以随机访问O(1)；
内存利用率不高，无法动态分配回收内存，删除插入元素需要在内存大量移动元素
适用于较少的数据，经常按序号访问，易实现，较稳定

链表：
内存利用率高，可动态添加删除元素，不用移动元素，只需要修改指针即可
需要额外空间存储指针维护链表结构，内存占用多，不能随机访问，只能通过指针顺次访问O(n)
适用于规模难以估计的数据，频繁插入删除，动态性较强

【2.栈和队列】

都是有操作限制的线性表

栈：栈是限定在表尾进行增删的线性表；称为后进先出（last in first out, LIFO）；
top指针指向最后一个进栈的元素；

数组实现
链表实现，使用链表头插法，链表head作为栈的top

队列：只允许在尾部插入，在头部删除的线性表；称为先进先出（first in first out, FIFO）

链表实现，需要维护first，last节点指针，链表head作为first

斐波那契数列：动态规划法类似于队列，a指向b，头部删除a， b指向a+b，尾部插入a+b

进制转换：用栈依次储存低位到高位的余数

迷宫求解：利用栈储存探索路径，若路径不是通路且不是终点就将路径出栈，回退到岔路（可探索的那个点）；
每一次探索时都要标记已经走过的路径，确保路径不重复

中缀表达式转后缀表达式：逆波兰表示法，操作符后置，不需要括号来表示操作符的优先级，每个操作符都只针对两个字符；
利用栈依次存放操作符，优先级越高的越先出栈，左括号到右括号内的操作符立刻出栈

后缀表达式求值：利用栈，对表达式所有字符从左到右依次入栈，对栈顶操作符和其下两数字进行运算再重新入栈

【3.树】

一种有限集，根root，孩子child，双亲parent，叶子leaf，层次level，子树subtree；
根节点到任一子节点只有一条路径

二叉树：每个子节点最多两个分支，左子树，右子树；满二叉树，完全二叉树；
属性：第i层至多有2^(i-1)个节点，层数为k的二叉树最多2^k-1个节点，
任一二叉树，终端节点书n，度为2的节点数t，则n=t+1

二叉树遍历：
前序遍历：根，左，右
中序遍历：左，根，右
后序遍历：左，右，根
层序遍历：逐层访问

【4.查找】

线性查找O(n)，二分查找O(logn)，插值查找O(logn)适合均匀数组，预估一个位置进行查找



