【事务】

一组操作，ACID特性，Commit提交一个事务，Rollback回滚
回滚利用回滚日志，反向执行操作记录

ACID特性

原子性，一致性，隔离性，持久性

原子性+隔离性 = （并发下）一致性 ： 执行结果正确
持久性 ： 应对系统崩溃

MySQL AUTOCOMMIT

【并发一致性问题】

并发情况下，事务的隔离性难以保证

丢失修改：一个操作被另一个操作替换
读脏数据：一个操作读到了另一个操作未commit的数据
不可重复读：多次重复读取数据时被另一个事务修改了
幻影读：在某个范围读取的数据被另一个事务插入了

【封锁】

采用并发控制：封锁 来保证隔离性

封锁粒度：越细开销越大

封锁类型：
1.读写锁：互斥锁，X锁，写锁（读写）
		  共享锁，S锁，读锁（读）
		  对于某个数据，只有S锁可以叠加
2.意向锁：加入意向锁降低检测数
		  IX/IS锁，先IX再X，先IS再S
	      IX/IS锁只是意向锁，并未真正加锁，表级上是兼容的

封锁协议：
1.三级封锁协议：一级：修改数据时需加X锁，解决丢失修改问题（修改时不能再修改）
				二级：读取数据时需加S锁，解决脏读问题（修改时不能读取）
				三级：读取数据时需加S锁，直到事务结束了才能释放S锁（读取时不能修改）
2.两段锁协议：加锁和解锁分为两个阶段进行； 事务遵循两段锁协议是保证可串行化调度的充分条件，非必要条件

MySQL隐式与显式锁定：InnoDB 存储引擎采用两段锁协议，自动加锁，也可以手动

【隔离级别】

未提交读：事务中的修改，即使未修改，也是对其它事务可见的
提交读：只能读取/修改提交的数据，解决脏读
可重复读：保证同一事务多次读取统一数据结果一样，解决不可重复读
可串行化：强制事务串行执行，解决所有并发一致性问题

【多版本并发控制】MVCC，Multi-Version Concurrency Control

实现提交读和可重复读这两种隔离级别

利用快照，读取只能读已提交的快照

通过回滚指针ROLL_PTR把一个数据行的所有快照连接起来

INSERT UPDATE DELETE操作会创建一个日志
Undo日志：事务版本号+DEL字段+操作

ReadView：当前系统未提交的事务列表

快照读（读快照不必加锁）与当前读

（补）【Next-Key Locks】

解决幻影读

【关系数据库设计理论】

函数依赖  A->B A决定B

异常：冗余数据，修改异常，删除异常，插入异常

？？？范式：1NF 属性不可分
	  2NF 非主属性完全函数依赖于键码
	  3NF 非主属性不传递函数依赖于键码

（补）【ER图】Entity-Relationship

实体，属性，联系